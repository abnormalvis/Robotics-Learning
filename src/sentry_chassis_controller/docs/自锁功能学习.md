# 纯上位机ROS舵轮底盘自锁实现与测试方案

## 一、自锁实现原理

在纯上位机ROS架构中，"自锁"指当没有速度指令时，底盘通过**主动控制**保持位置锁定，而非依赖机械刹车。核心思路是：**无指令时自动切换为位置保持模式**，通过PID控制维持当前位姿。

根据搜索结果，舵轮底盘通常有`CHASSIS_RELAX`（放松）和`CHASSIS_STOP`（停止）等模式，自锁实现的关键在于**正确切换控制模式**并**保持电机力矩输出**。

---

## 二、具体实现方法

### 方法1：零速度指令持续发布（推荐）

**原理**：检测到无新指令时，持续发布零速度指令给电机驱动器。

**ROS实现**：

```cpp
// 在底盘控制节点中
ros::Subscriber cmd_sub = nh.subscribe("cmd_vel", 10, cmdVelCallback);
ros::Timer safety_timer = nh.createTimer(ros::Duration(0.1), timerCallback); // 100ms超时

geometry_msgs::Twist last_cmd;
ros::Time last_cmd_time;

void cmdVelCallback(const geometry_msgs::Twist::ConstPtr& msg) {
    last_cmd = *msg;
    last_cmd_time = ros::Time::now();
    // 正常速度控制
    controlWheels(msg->linear.x, msg->linear.y, msg->angular.z);
}

void timerCallback(const ros::TimerEvent&) {
    // 超过100ms未收到指令，自动锁定
    if (ros::Time::now() - last_cmd_time > ros::Duration(0.1)) {
        // 发布零速度
        geometry_msgs::Twist zero_cmd;
        zero_cmd.linear.x = 0;
        zero_cmd.linear.y = 0;
        zero_cmd.angular.z = 0;
        controlWheels(0, 0, 0); // 关键：持续调用控制函数
    }
}
```

**优点**：实现简单，兼容性好  
**缺点**：依赖通信稳定性

---

### 方法2：PID位置保持模式（高精度）

**原理**：无指令时切换到**位置闭环**，将当前编码器位置作为目标值锁定。

参考RoboMaster舵轮代码中的模式切换逻辑：

```cpp
// 底盘状态枚举
enum ChassisMode {
    CHASSIS_NORMAL,    // 正常速度控制
    CHASSIS_LOCK,      // 自锁保持
    CHASSIS_RELAX      // 放松（电流设为0）
};

ChassisMode current_mode = CHASSIS_NORMAL;
double lock_positions[4]; // 4个舵轮电机位置

void enterLockMode() {
    current_mode = CHASSIS_LOCK;
    // 记录当前各电机位置作为目标
    for (int i = 0; i < 4; i++) {
        lock_positions[i] = getMotorPosition(i);
    }
}

void controlLoop() {
    if (ros::Time::now() - last_cmd_time > ros::Duration(0.1)) {
        if (current_mode != CHASSIS_LOCK) {
            enterLockMode();
        }
    }

    if (current_mode == CHASSIS_LOCK) {
        // PID位置保持
        for (int i = 0; i < 4; i++) {
            double current_pos = getMotorPosition(i);
            double output = pid_calc(&pid_controller[i], current_pos, lock_positions[i]);
            setMotorCurrent(i, output); // 持续输出力矩
        }
    } else {
        // 正常速度控制
        // ...
    }
}
```

**关键配置**：
- **转向电机**：位置PID参数要**刚度大**（P值高），确保不晃动
- **行进电机**：速度PID的I参数适当增大，消除静差

**优点**：锁定精度高，抗干扰能力强  
**缺点**：需要精细调参，电机持续耗电

---

### 方法3：驱动器层刹车模式

**原理**：利用电机驱动器的**电子刹车**功能（如RoboMaster M3508的短路刹车）。

**实现方式**：
```cpp
// 通过CAN发送刹车指令
void setMotorBrake(int motor_id) {
    can_msg.data[0] = 0x00; // 特殊指令码
    can_msg.data[1] = 0x01; // 刹车使能
    // ... 发送CAN报文
}

// 无指令时调用
if (no_command_timeout) {
    for (int i = 0; i < 8; i++) { // 4行走+4转向
        setMotorBrake(i);
    }
}
```

**注意事项**：频繁切换可能导致电机发热，适合长时间静止场景

---

## 三、测试效果的方法

### 1. **手动推力测试**
```bash
# 启动底盘节点
roslaunch your_robot chassis.launch

# 1. 发送速度指令后停止
rostopic pub -1 /cmd_vel geometry_msgs/Twist "linear:
  x: 0.5
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0"

# 2. 停止发送指令，等待1秒
# 3. 用手尝试推动底盘

# 预期结果：底盘无法被推动，或推动后自动回位
```

### 2. **斜坡静置测试**
将底盘放在**5°斜坡**上，停止指令后观察：
- **合格**：10分钟内位置漂移<1cm
- **不合格**：底盘自行下滑

### 3. **数据监测测试**

```python
# 监控脚本
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState

def monitor():
    rospy.init_node('lock_monitor')
    last_cmd_time = rospy.Time.now()
    
    def cmd_cb(msg):
        nonlocal last_cmd_time
        last_cmd_time = rospy.Time.now()
    
    def joint_cb(msg):
        # 检查电机位置波动
        if rospy.Time.now() - last_cmd_time > rospy.Duration(0.5):
            positions = msg.position
            print(f"锁定中 - 位置波动: {max(positions) - min(positions):.4f} rad")
    
    rospy.Subscriber('/cmd_vel', Twist, cmd_cb)
    rospy.Subscriber('/joint_states', JointState, joint_cb)
    rospy.spin()

# 合格标准：位置波动 < 0.01rad（约0.57°）
```

### 4. **ROS工具链测试**
```bash
# 方式A：使用rqt_plot监控
rosrun rqt_plot rqt_plot /joint_states/position[0]

# 方式B：记录数据并分析
rosbag record -O lock_test /cmd_vel /joint_states /motor_currents
# 回放分析位置稳定性
```

---

## 四、关键参数配置建议

| 参数 | 推荐值 | 说明 |
|------|--------|------|
| 指令超时时间 | 0.1-0.2s | 过短易误判，过长响应慢 |
| 锁定PID的P值 | 80-150 | 刚度足够，避免振荡 |
| 锁定PID的I值 | 0-5 | 消除静差，防止积分饱和 |
| 锁定PID的D值 | 0-2 | 阻尼振荡，通常设为0 |
| 测试斜坡角度 | 3-5° | 模拟实际地面不平度 |

---

## 五、注意事项

1. **电流限制**：锁定模式下设置**最大电流限制**（如3A），防止电机过热
2. **通信延迟**：确保CAN总线周期<10ms，避免锁定时延
3. **电机选型**：优先选择**带编码器**的伺服电机（如GM6020），而非普通无刷电机
4. **电源管理**：长时间锁定建议切换到**低功耗模式**，而非全力矩锁定

通过以上方案，可在纯ROS上位机架构下实现可靠的舵轮底盘自锁功能，并通过系统性测试验证效果。