# 里程计更新原理详解（odom_update 函数）

本文档详细说明 `WheelPidController::odom_update()` 函数的业务逻辑、数学原理、坐标变换与 TF 发布机制。

---

## 一、功能概述

`odom_update` 函数的核心任务是：
1. **从四个舵轮的反馈数据（轮速、舵角）推算底盘在机体坐标系下的速度**（前向运动学，Forward Kinematics）。
2. **将机体速度积分到世界坐标系（odom）**，得到底盘位姿（位置 + 航向）。
3. **发布 TF 变换**（`odom` → `base_link`）以及 **里程计消息**（`nav_msgs::Odometry`）供导航栈使用。

**关键特点**：
- 使用**四轮超定系统**（4 个观测值，3 个未知数：vx, vy, wz）通过**最小二乘**求解，提升鲁棒性与精度。
- 适用于**舵轮底盘**（每个轮子有独立的舵角 + 轮速反馈）。
- 实时计算并发布，供上层路径规划、定位融合使用。

---

## 二、舵轮前向运动学模型（FK, Forward Kinematics）

### 2.1 物理模型与坐标系

**坐标系定义**（REP-105 标准右手坐标系）：
- `base_link`（机体坐标系）：x 轴向前，y 轴向左，z 轴向上。
- `odom`（世界/里程计坐标系）：固定参考系，原点在初始位置，方向与世界对齐。

**轮子布局**（四个舵轮，相对 base_link 中心的位置）：
```
    前          x 轴（向前）
   FL ---- FR   
    |      |
   RL ---- RR
         y 轴（向左）
```
- 前左（FL）：位置 (rx, ry) = (wheel_base/2, wheel_track/2)
- 前右（FR）：位置 (rx, -ry) = (wheel_base/2, -wheel_track/2)
- 后左（RL）：位置 (-rx, ry) = (-wheel_base/2, wheel_track/2)
- 后右（RR）：位置 (-rx, -ry) = (-wheel_base/2, -wheel_track/2)

### 2.2 单轮运动学关系

对于第 i 个轮子：
- **输入**：轮速角速度 $\omega_i$ (rad/s)，舵角 $\theta_i$ (rad)
- **物理含义**：轮子沿其舵向（方向角 $\theta_i$）以线速度 $v_{wheel,i} = \omega_i \times r_{wheel}$ 滚动
- **机体速度与轮速关系**（假设底盘在机体系下速度为 $(v_x, v_y, \omega_z)$）：

$$
v_{wheel,i} = \begin{bmatrix} \cos\theta_i & \sin\theta_i & -r_{y,i}\cos\theta_i + r_{x,i}\sin\theta_i \end{bmatrix} \begin{bmatrix} v_x \\ v_y \\ \omega_z \end{bmatrix}
$$

其中：
- $r_{x,i}, r_{y,i}$：轮子相对底盘中心的坐标（沿 x/y 方向）
- $\cos\theta_i, \sin\theta_i$：舵角对应的单位方向向量
- 第三项 $-r_{y,i}\cos\theta_i + r_{x,i}\sin\theta_i$：由于底盘旋转（$\omega_z$）引起该轮子位置的切向速度分量在舵向上的投影

### 2.3 超定线性系统（4 轮 → 3 未知数）

将四个轮子写成矩阵形式：
$$
\mathbf{A} \mathbf{x} = \mathbf{b}
$$
其中：
- $\mathbf{x} = \begin{bmatrix} v_x \\ v_y \\ \omega_z \end{bmatrix}$ （3×1，待求底盘速度）
- $\mathbf{A}$ 是 4×3 系数矩阵，每行对应一个轮子的运动学方程系数
- $\mathbf{b} = \begin{bmatrix} v_{wheel,0} \\ v_{wheel,1} \\ v_{wheel,2} \\ v_{wheel,3} \end{bmatrix}$ （4×1，四个轮子的实测线速度）

**超定系统**：有 4 个观测方程但只有 3 个未知数，通常无精确解（由于测量误差、滑移、舵角对齐误差等），需用**最小二乘**求最优近似解。

### 2.4 最小二乘求解（Least Squares）

目标：最小化残差平方和
$$
\min_{\mathbf{x}} \|\mathbf{A}\mathbf{x} - \mathbf{b}\|^2
$$

**解析解**（法方程，Normal Equation）：
$$
\mathbf{A}^T \mathbf{A} \mathbf{x} = \mathbf{A}^T \mathbf{b}
$$
即
$$
\mathbf{x} = (\mathbf{A}^T \mathbf{A})^{-1} \mathbf{A}^T \mathbf{b}
$$

代码中实现：
1. 计算 $\mathbf{A}^T \mathbf{A}$ （3×3 对称矩阵）和 $\mathbf{A}^T \mathbf{b}$ （3×1 向量）
2. 求 3×3 矩阵的行列式 det，判断是否奇异
3. 若 $|\text{det}| > 10^{-9}$，计算逆矩阵并求解 $\mathbf{x}$；否则输出警告并使用零速度

**优点**：
- 利用所有四个轮子的信息，减小单轮误差影响
- 对打滑、测量噪声有一定容错性
- 计算量小（3×3 矩阵求逆，固定运算量）

**局限**：
- 若四轮舵角高度相关（例如所有轮平行），矩阵可能接近奇异，解不稳定
- 严重打滑时（如冰面、急加速）会导致估计误差
- 未考虑滑移补偿或IMU融合

---

## 三、坐标变换与里程计积分

### 3.1 从机体速度到世界速度（旋转变换）

最小二乘求得的 $(v_x, v_y, \omega_z)$ 是**机体坐标系下的速度**（base_link frame）。为了在 odom 坐标系中积分位置，需将其旋转到世界系。

**旋转公式**（2D 平面旋转矩阵）：
$$
\begin{bmatrix} v_{world,x} \\ v_{world,y} \end{bmatrix} = \begin{bmatrix} \cos\psi & -\sin\psi \\ \sin\psi & \cos\psi \end{bmatrix} \begin{bmatrix} v_x \\ v_y \end{bmatrix}
$$
其中 $\psi$ 是底盘当前在 odom 系中的航向角（yaw）。

代码实现：
```cpp
double cos_y = std::cos(odom_yaw_);
double sin_y = std::sin(odom_yaw_);
double world_vx = vx * cos_y - vy * sin_y;
double world_vy = vx * sin_y + vy * cos_y;
```

### 3.2 位置与航向积分（欧拉积分）

使用一阶欧拉法积分世界速度：
$$
\begin{aligned}
x_{odom} &\leftarrow x_{odom} + v_{world,x} \times \Delta t \\
y_{odom} &\leftarrow y_{odom} + v_{world,y} \times \Delta t \\
\psi_{odom} &\leftarrow \psi_{odom} + \omega_z \times \Delta t
\end{aligned}
$$

其中 $\Delta t$ 是控制周期（`period.toSec()`）。

**注意**：
- 航向 $\psi$ 直接用机体角速度 $\omega_z$ 积分（无需坐标变换，因为角速度在 2D 平面旋转下不变）
- 欧拉积分简单但累积误差较大，长时间运行建议融合 IMU/视觉/激光里程计

---

## 四、TF 变换发布（odom → base_link）

### 4.1 TF 树结构

ROS 导航栈标准 TF 树（REP-105）：
```
map → odom → base_link → [sensors...]
```

本函数负责发布 **odom → base_link** 变换，描述底盘在里程计坐标系中的位姿。

### 4.2 变换内容

- **平移**（Translation）：
  - x = odom_x_
  - y = odom_y_
  - z = 0.0 （假设平面运动）

- **旋转**（Rotation，四元数表示）：
  - 从欧拉角 (roll=0, pitch=0, yaw=odom_yaw_) 转为四元数
  - 使用 `tf2::Quaternion::setRPY(0, 0, odom_yaw_)`

### 4.3 代码实现

```cpp
geometry_msgs::TransformStamped t;
t.header.stamp = now;
t.header.frame_id = odom_frame_;      // 父坐标系（odom）
t.child_frame_id = base_link_frame_;  // 子坐标系（base_link）
t.transform.translation.x = odom_x_;
t.transform.translation.y = odom_y_;
t.transform.translation.z = 0.0;

tf2::Quaternion qtn;
qtn.setRPY(0.0, 0.0, odom_yaw_);
t.transform.rotation.x = qtn.getX();
// ... (其他四元数分量)

tf_broadcaster_.sendTransform(t);
```

**用途**：
- 上层节点（如 `move_base`, `amcl`）可通过 TF 查询底盘位姿
- 传感器数据（如激光、相机）可通过 TF 树转换到 odom 或 map 坐标系

---

## 五、里程计消息发布（nav_msgs::Odometry）

### 5.1 消息结构

`nav_msgs::Odometry` 包含两部分：
1. **pose.pose**：底盘在 odom 坐标系中的位姿（位置 + 四元数姿态）
2. **twist.twist**：底盘的速度（**在 child_frame_id 即 base_link 坐标系下**）

### 5.2 关键字段

- **header.frame_id** = `odom_frame_`：位姿参考系
- **child_frame_id** = `base_link_frame_`：速度参考系
- **pose.pose.position**：(odom_x_, odom_y_, 0)
- **pose.pose.orientation**：与 TF 相同的四元数（表示 yaw）
- **twist.twist.linear**：机体坐标系速度 (vx, vy, 0)
- **twist.twist.angular**：角速度 (0, 0, wz)

**重要**：
- `twist` 中的速度是**机体系（base_link）速度**，非世界系速度
- 这符合 ROS 标准约定（child_frame_id 指明速度坐标系）
- 导航栈会自动通过 TF 查询转换到所需坐标系

### 5.3 代码片段

```cpp
nav_msgs::Odometry odom;
odom.header.stamp = now;
odom.header.frame_id = odom_frame_;
odom.child_frame_id = base_link_frame_;

odom.pose.pose.position.x = odom_x_;
odom.pose.pose.position.y = odom_y_;
odom.pose.pose.orientation = /* 四元数 */;

odom.twist.twist.linear.x = vx;   // 机体 x 方向速度
odom.twist.twist.linear.y = vy;   // 机体 y 方向速度
odom.twist.twist.angular.z = wz;  // 绕 z 轴角速度

odom_pub_.publish(odom);
```

---

## 六、算法流程总结（执行步骤）

1. **读取传感器数据**：
   - 四个轮子的角速度 $\omega_i$ （通过 `joint.getVelocity()`）
   - 四个舵角 $\theta_i$ （通过 `pivot_joint.getPosition()`）

2. **构造最小二乘方程**：
   - 计算每个轮子的线速度 $v_{wheel,i} = \omega_i \times r_{wheel}$
   - 组装系数矩阵 $\mathbf{A}$ (4×3) 和观测向量 $\mathbf{b}$ (4×1)

3. **求解机体速度**：
   - 计算 $\mathbf{A}^T \mathbf{A}$ 和 $\mathbf{A}^T \mathbf{b}$
   - 求行列式并检查奇异性
   - 计算 3×3 逆矩阵并求解 $(v_x, v_y, \omega_z)$

4. **坐标变换**：
   - 将机体速度旋转到世界系：$(v_{world,x}, v_{world,y})$

5. **位姿积分**：
   - 欧拉积分更新 odom_x_, odom_y_, odom_yaw_

6. **发布 TF 与 Odometry**：
   - 广播 odom → base_link 的 TF 变换
   - 发布 `nav_msgs::Odometry` 消息（位姿用世界系，速度用机体系）

---

## 七、边界情况与鲁棒性考虑

### 7.1 矩阵奇异性（det ≈ 0）

**原因**：
- 四个轮子舵角高度共线（例如全部指向同一方向）
- 轮子打滑导致实际速度与期望严重偏离
- 初始化阶段传感器未就绪

**处理**：
- 代码检查 $|\text{det}| > 10^{-9}$，若不满足则输出警告并使用零速度
- 建议：可改为使用上一时刻速度或基于命令速度的开环估计作为回退

### 7.2 累积误差（Drift）

**原因**：
- 欧拉积分的截断误差
- 轮子打滑、地面不平、轮径误差
- 舵角对齐误差

**缓解措施**：
- 融合 IMU（提供更准确的角速度与航向）
- 融合视觉里程计或激光里程计（SLAM）
- 定期通过地标或全局定位（AMCL, GPS）校正

### 7.3 高速旋转时的离散化误差

**问题**：
- 当 $\omega_z$ 很大且 $\Delta t$ 不够小时，欧拉积分假设在 $\Delta t$ 内航向不变，导致轨迹失真

**改进**：
- 使用龙格-库塔法（Runge-Kutta）或中点法积分
- 提高控制频率（减小 $\Delta t$）

---

## 八、与其他模块的接口

### 8.1 输入依赖

- **关节状态**：由 Gazebo 或真实硬件的 JointStateController 提供
- **控制周期**：update() 函数在每个控制周期调用（通常 100–1000 Hz）
- **运动学参数**：wheel_base, wheel_track, wheel_radius（从 YAML 读取）

### 8.2 输出提供

- **TF 广播**：供 `tf2` 库查询，用于传感器数据转换、路径规划等
- **Odometry 话题**：供 `move_base` 等导航节点订阅，用于速度反馈与位置估计
- **话题名称**：默认 `odom_controller`（可在参数中配置为 `odom`）

### 8.3 与其他里程计节点的关系

- 项目中同时存在 `forward_kinematics` 节点（从 `/joint_states` 计算 FK 并发布 odom）
- 控制器内嵌的 `odom_update` 作用相同，但运行在控制器内部（更低延迟）
- 建议：根据需求选择一个主里程计源，避免冲突（例如通过参数开关禁用其中一个）

---

## 九、调试与验证建议

### 9.1 可视化 TF 树

```bash
rosrun rqt_tf_tree rqt_tf_tree
# 或
rosrun tf2_tools view_frames.py
evince frames.pdf
```
确认 odom → base_link 变换正常广播。

### 9.2 监控里程计数据

```bash
rostopic echo /odom_controller
```
检查 pose 和 twist 是否合理（例如静止时速度应为零，运动时方向符合预期）。

### 9.3 对比前向运动学节点

如果同时运行 `forward_kinematics` 节点，对比两个 odom 源的输出：
```bash
rostopic echo /odom          # forward_kinematics 发布
rostopic echo /odom_controller  # 控制器内嵌发布
```
两者应基本一致（轻微时延差异可接受）。

### 9.4 检查矩阵奇异性

在仿真或实测中观察日志，若频繁出现 "前向运动学矩阵奇异" 警告，需检查：
- 轮子舵角是否卡死或控制失效
- 传感器是否正常反馈
- 运动学参数（wheel_base/track/radius）是否正确

---

## 十、改进方向与扩展

### 10.1 更高阶的积分方法

- 用 RK4 或中点法替代欧拉积分，减小离散误差
- 在高速或高转速场景下效果明显

### 10.2 滑移检测与补偿

- 对比期望轮速（从 IK 计算）与实际轮速，检测异常打滑
- 引入滑移模型或自适应系数降低打滑轮子的权重

### 10.3 IMU 融合

- 用扩展卡尔曼滤波（EKF）或无迹卡尔曼滤波（UKF）融合轮式里程计与 IMU
- ROS 中可用 `robot_localization` 包实现多传感器融合

### 10.4 协方差估计

- 在 `nav_msgs::Odometry` 中填充 `pose.covariance` 和 `twist.covariance`
- 供 EKF 等融合算法使用，提高定位精度与可靠性

---

## 十一、参考资料

1. **ROS REP-105**：坐标系标准（map, odom, base_link）  
   [https://www.ros.org/reps/rep-0105.html](https://www.ros.org/reps/rep-0105.html)

2. **最小二乘法**：线性代数与数值分析教材（Golub & Van Loan, *Matrix Computations*）

3. **舵轮运动学**：  
   - 《Introduction to Autonomous Mobile Robots》(Siegwart et al.)
   - 四轮独立转向（4WIS）文献

4. **TF2 官方文档**：  
   [http://wiki.ros.org/tf2](http://wiki.ros.org/tf2)

5. **robot_localization 包**（多传感器融合）：  
   [http://docs.ros.org/en/noetic/api/robot_localization/html/index.html](http://docs.ros.org/en/noetic/api/robot_localization/html/index.html)

---

**总结**：`odom_update` 函数通过舵轮前向运动学（最小二乘求解）、坐标变换与欧拉积分，实时估计底盘位姿并发布 TF 与里程计消息，为导航与定位提供基础支撑。在理解其数学原理的基础上，可针对实际应用场景进行优化与扩展（如融合 IMU、改进积分方法、增加滑移检测等）。
