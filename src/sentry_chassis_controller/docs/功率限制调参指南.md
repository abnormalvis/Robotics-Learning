# 功率限制调参指南

简要说明如何在 `config` / YAML 中设置 `power_limit`, `power_offset`, `effort_coeff`, `velocity_coeff`，以及如何观察调试信息并逐步调参。

## 目标
- 在下发轮子扭矩/力矩命令时保护电源与驱动器，避免瞬时或持续功率超过设定上限。

## 参数说明（出现在 `wheel_pid_params.yaml` 或控制器命名空间下）
- `power_limit` (单位：W)：目标功率上限（瓦特）。当估算的功率指标超限时，控制器会尝试缩放所有轮子的命令以满足该上限。默认0表示禁用/不限制。
- `power_offset` (单位：W)：基线或偏置功率（可用于补偿常驻功率消耗），在计算中会从允许上限里减去。
- `effort_coeff` (无量纲或按需缩放)：与扭矩平方项相乘的系数，用于把 torque^2 映射到功率模型的二次项（代码中用于计算 a）。初始可设为 0，按需增加以对高扭矩值进行额外惩罚。
- `velocity_coeff` (无量纲或按需缩放)：与角速度平方项相乘的系数（代码中用于计算 c 的速度平方贡献）。初始可设为 0，或用于反映速度相关的耗散量。
- `power_debug` (bool)：开启时会在话题 `power_debug` 发布数组 [a, b, c, disc, scaling_factor]，用于在线调试。

注意：代码实际计算的功率近似模型为

    F(s) = a*s^2 + b*s + c

其中 s 是统一缩放因子，a = effort_coeff * sum(cmd_i^2)，b = sum(|cmd_i * omega_i|)，c = velocity_coeff * sum(omega_i^2) - power_offset - power_limit。

当 F(s) ≤ 0 时表示满足功率约束；算法解析求得最大 s 并把所有 cmd_i 乘以该 s。

## 调参建议（逐步）
1. 初始禁用：先把 `power_limit` 设为 0（或保持默认）以观察无约束时系统行为，确保 PID 等控制器参数已大致收敛。
2. 确定电源/电机极限：从硬件手册或实测得到目标瞬时功率上限（例如电机驱动器峰值输出或电池允许的放电功率），把该值设为 `power_limit`（单位 W）。若不清楚，可先给较保守值，例如 100–300 W（按车辆/电机规模调整）。
3. 先把 `effort_coeff` 和 `velocity_coeff` 设为 0，启用 `power_debug: true`；运行并记录在各速度/加速场景下 `power_debug` 的 a/b/c 值以及计算出的 `scaling_factor`。
4. 通过观察 `b`（sum |cmd*omega|）与 `power_limit` 的差，评估是否需要引入 `effort_coeff` 或 `velocity_coeff` 来更好地拟合或惩罚极端扭矩与速度：
   - 如果系统在高扭矩命令下频繁触发缩放，但实际能耗并不如计算保守，考虑降低或保留 `effort_coeff=0`；
   - 若速度平方对能耗有明显贡献（例如高速下拖拽/风阻），可把 `velocity_coeff` 设为小正数以将速度贡献考虑进约束。
5. 小步调整：每次只改一个参数，幅度小（例如 0.01–0.1 量级），观察 `power_debug` 中 disc 与 scaling 的变化，直到在典型运行场景下 `scaling_factor` 接近 1 且不频繁触发缩放；在极限测试下 scaling 会降至 <1。
6. 平滑与安全：建议在控制器外或内部对 `scaling_factor` 做低通滤波（例如第一阶滤波 tau=0.1–0.5s）以避免命令突变导致车辆不稳定；并为 `disc<=0` 情况增加安全退避（例如默认把 scaling 设为 0.5 并上报警告），以避免出现未处理的超限情况。

## YAML 示例
示例片段可加入 `sentry_chassis_controller` 的配置文件：

```yaml
# 功率限制示例（单位：W）
power_limit: 200.0
power_offset: 5.0
effort_coeff: 0.0
velocity_coeff: 0.0
power_debug: true
```

说明：上述配置对多数小型底盘是保守起步值；请根据实际电源/电机规格调整 `power_limit`。

## 如何查看调试数据
- 在终端使用：
```
rostopic echo /power_debug
```
- 输出数组含义（索引）：
  - [0] = a (与 torque^2 相关项)
  - [1] = b (sum |cmd * omega|，近似瞬时机械功率线性项)
  - [2] = c (速度平方贡献 - offset - limit)
  - [3] = disc (判别式 b^2 - 4*a*c)
  - [4] = scaling_factor (计算得到用于缩放命令的 s)

当 `scaling_factor < 1.0` 时表示控制器正在缩放命令以满足当前 `power_limit`；用典型动作（例如急加速）测试并记录这些值，便于回归调参。

## 常见问题与建议
- 若系统过于保守（经常缩放，但能承受更多），优先将 `effort_coeff` 设置为 0 或减小 `velocity_coeff`。保守设置通常是安全的，但会影响性能。
- 若系统偶尔出现 `disc <= 0`（判别式非正），建议不要直接无动作，而是采取保守缩放（例如 s=0.5）并记录日志以便离线分析。
- 若平台支持能量回收（再生制动），考虑在模型中保留符号而非取绝对值，从而允许回生功率抵消消耗（实现更准确的限幅）。

---
如需，我可以把上述建议自动化为一个调参脚本（采集典型动作下的 `power_debug` 数据并给出推荐参数），或直接在控制器里加入 `scaling_factor` 的低通滤波补丁，你希望我做哪一种？
