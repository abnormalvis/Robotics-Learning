# ADRC 自抗扰控制

ADRC（Active Disturbance Rejection Control，自抗扰控制）是一类**把“未知扰动 + 未建模动态”统一当作总扰动，并在线估计与补偿**的控制方法。它在工程上常被用来解决：

- 模型不准、参数变化大
- 外界扰动强、负载变化频繁
- 需要较强鲁棒性且调参希望“更像 PID”

ADRC 最经典的“韩京清三件套”结构：

1. **TD**（Tracking Differentiator，跟踪微分器）：把参考输入变平滑，并给出参考的一阶/二阶导。
2. **ESO**（Extended State Observer，扩张状态观测器）：把“总扰动”扩张为一个状态并实时估计。
3. **NLSEF/SEF**（Nonlinear/State Error Feedback，非线性/线性误差反馈）：对“补偿后的对象”做反馈控制（可看作“更强的 PID/PD”）。

下面按“核心思想 → 数学建模 → 离散实现 → 调参经验 → 常见问题”展开。

---

## 1. 核心思想：把一切不确定性当成总扰动

考虑一个单输入单输出（SISO）系统。很多实际对象都可以近似写成（以二阶为例）：

$$
\ddot y = f(y,\dot y,t) + b\,u
$$

- $y$：输出
- $u$：控制输入
- $b$：输入增益（可以只知道一个大概，记为 $b_0$）
- $f(\cdot)$：把**外界扰动、摩擦、负载变化、未建模项、参数漂移**等全部揉在一起的“未知项”

ADRC 的思路是：

1) 用 ESO 在线估计 $f$（称为“总扰动”或“扩张状态”）；
2) 控制律里显式补偿它：$u = (v - \hat f)/b_0$；
3) 这样“被补偿后的对象”近似变成：

$$
\ddot y \approx v
$$

最后的问题就变成“给一个理想的二阶积分环节设计 $v$”，这和做 PD/状态反馈非常接近。

下面把这三步讲得更具体一些（用工程语言解释它到底在干嘛）。

### 1.1 什么叫“总扰动” $f$？它到底包含了哪些东西

在式子

$$
\ddot y = f(y,\dot y,t) + b\,u
$$

里，ADRC 的关键不是“把 $f$ 当成某个具体的外界扰动”，而是把你不想/不能建模的一切都塞进 $f$。例如：

- **外扰**：外力推/风/路面坡度、负载突然变化
- **内扰**：摩擦、齿隙、弹性、饱和造成的等效非线性
- **模型不准**：真实系统不是二阶、耦合项没写、参数随温度变
- **增益误差的一部分**：如果你只知道 $b\approx b_0$，那么
	$$
	\ddot y = f + b_0 u + (b-b_0)u
	$$
	也可以把 $(b-b_0)u$ 当作“输入相关扰动”并让 ESO 去吸收（当然 $b_0$ 不能差得离谱）。

所以“总扰动”更像是：**系统在当前时刻偏离理想模型的那一坨东西**。

### 1.2 为什么 ESO 能估计到 $f$？直观理解

你能测到 $y$，也知道自己打了多大控制 $u$。如果系统满足

$$
\ddot y - b_0 u = f + (b-b_0)u
$$

那么左边（由输出变化趋势与输入决定）就携带了关于 $f$ 的信息。

ESO 做的事可以理解成：

- 用一个“很快的动态系统”把 $y$ 的误差 $e=y-\hat x_1$ 不断反馈进去；
- 同时把已知的 $b_0 u$ 注入到观测器；
- 让 $\hat x_1\approx y$、$\hat x_2\approx \dot y$，并把“解释不了的那部分加速度”归到 $\hat x_3\approx f$。

这也是为什么 **观测器带宽 $\omega_o$** 很关键：

- $\omega_o$ 大：ESO 更快把误差“吃掉”，$\hat f$ 跟得紧，但更容易把测量噪声也当成扰动
- $\omega_o$ 小：估计更平滑，但扰动补偿滞后

### 1.3 “补偿”到底补偿了什么？为什么补偿后就像双积分

ADRC 的核心控制律：

$$
u = \frac{v - \hat f}{b_0}
$$

把它代回去（并假设 $\hat f\approx f$、$b\approx b_0$），你得到：

$$
\ddot y \approx v
$$

这句话的工程含义是：

- 原来对象“很复杂”：你一给 $u$，输出加速度里既有控制作用、也有各种扰动/非线性在捣乱
- 现在对象“更理想”：你选择一个虚拟输入 $v$，系统就尽量按 $\ddot y=v$ 去走

因此 ADRC 把控制问题拆成两块：

1. **估扰动**（ESO）：让 $\hat f$ 尽量接近真实的总扰动
2. **做反馈**（设计 $v$）：在“近似双积分”的对象上做你熟悉的 PD/状态反馈

可以把信号流写成一句话：

> 误差 $\to$ 设计 $v$（像 PD）$\to$ 用 $\hat f$ 做前馈抵消 $\to$ 得到最终 $u$。

### 1.4 一个非常具体的小例子：电机转速（或底盘速度）遇到负载突变

假设你在控转速 $y$，负载突然加大（等效阻力矩上升）。在传统 PID 里：

- 负载变化会让 $y$ 下跌
- 误差变大后，P/I/D 才开始“追着修”

在 ADRC 里：

- 负载变化会立刻体现在“系统加速度/变化率”异常上
- ESO 会更快把这部分异常归因到 $\hat f$ 增大
- 控制律里 $u=(v-\hat f)/b_0$ 会自动**提高输出的驱动**去抵消它

你会看到的典型效果是：

- 抗扰恢复更快（下跌幅度更小、回到目标更快）
- 对模型不准更不敏感（因为主要靠在线估计+补偿）

当然，前提仍然是：采样率足够、噪声不过分、$b_0$ 量级合理、饱和不要长期顶死。

---

## 2. 以二阶 ADRC 为主线：状态扩张 + ESO

### 2.1 扩张状态建模

令：

$$
x_1 = y,\quad x_2 = \dot y,\quad x_3 = f(y,\dot y,t)
$$

则系统可写为“扩张三阶系统”：

$$
\begin{aligned}
\dot x_1 &= x_2 \\
\dot x_2 &= x_3 + b\,u \\
\dot x_3 &= \dot f = w(t) \quad (\text{未知但有界})
\end{aligned}
$$

其中 $w(t)$ 表示扰动变化率（不需要精确模型，工程上只希望它别“无限快”）。

### 2.2 线性 ESO（LESO）

LESO 用一个三阶观测器估计 $(x_1,x_2,x_3)$：

$$
\begin{aligned}
\dot{\hat x}_1 &= \hat x_2 + \beta_1 (y-\hat x_1) \\
\dot{\hat x}_2 &= \hat x_3 + b_0 u + \beta_2 (y-\hat x_1) \\
\dot{\hat x}_3 &= \beta_3 (y-\hat x_1)
\end{aligned}
$$

- $b_0$：对真实 $b$ 的估计（粗略也行，但不能差太离谱）
- $\hat x_3 = \hat f$：对总扰动的估计
- $\beta_1,\beta_2,\beta_3$：观测器增益

一个非常常用的参数化方式是用**观测器带宽** $\omega_o$ 来设定：

$$
\beta_1 = 3\omega_o,\quad \beta_2 = 3\omega_o^2,\quad \beta_3 = \omega_o^3
$$

这相当于把 ESO 的特征多项式配置为 $(s+\omega_o)^3$（三重极点）。优点是调参直观：$\omega_o$ 越大，估计越快，但噪声放大也越严重。

---

## 3. 控制律：扰动补偿 + 误差反馈（像“更理想的 PD”）

在估计到总扰动 $\hat f = \hat x_3$ 后，ADRC 的核心补偿结构是：

$$
u = \frac{v - \hat f}{b_0}
$$

代回原系统：

$$
\ddot y = f + b\,u \approx f + b\,\frac{v-\hat f}{b_0}
$$

若 $\hat f \approx f$ 且 $b_0 \approx b$，则 $\ddot y \approx v$。

于是可以对“理想二阶系统”设计：

$$
v = k_p (r - \hat x_1) + k_d (\dot r - \hat x_2)
$$

- $r$ 是期望输出
- $\dot r$ 可以由 TD 或差分得到
- 使用 $\hat x_1,\hat x_2$ 而不是直接用 $y,\dot y$，可以降低微分噪声

若你更习惯“带宽调参”，也常用**闭环带宽** $\omega_c$：

$$
k_p = \omega_c^2,\quad k_d = 2\omega_c
$$

这样补偿后系统的期望闭环多项式近似为 $s^2 + 2\omega_c s + \omega_c^2$（临界阻尼）。

> 小结：LESO + 线性误差反馈（LSEF）版本的 ADRC，工程上最常用，也最容易落地。

---

## 4. TD（跟踪微分器）：让参考更“可控”，并提供导数

现实里参考 $r(t)$ 往往包含阶跃、尖峰或离散跳变。直接用 $\dot r$ 会导致控制冲击。

TD 的作用：

- 把 $r$ 变成一个平滑轨迹 $v_1$（跟踪 $r$）
- 给出 $v_2 \approx \dot v_1$（作为参考速度/导数）

在很多机器人/伺服系统中，如果你的参考本身已平滑（例如规划器输出含速度），TD 可以弱化甚至省略；但当参考是阶跃或人工输入时 TD 很有价值。

（不同实现差异较大：有 Han 的非线性 TD、有线性二阶滤波 TD。若你想最简实现，可用二阶低通/二阶跟踪系统来产生 $v_1,v_2$。）

---

## 5. 离散实现（控制循环中怎么写）

假设采样周期为 $T_s$，每次循环按“ESO 更新 → 计算 v → 计算 u”顺序。

### 5.1 离散化的 LESO（欧拉法示例）

令观测误差 $e = y - \hat x_1$：

$$
\begin{aligned}
\hat x_1 &\leftarrow \hat x_1 + T_s (\hat x_2 + \beta_1 e) \\
\hat x_2 &\leftarrow \hat x_2 + T_s (\hat x_3 + b_0 u + \beta_2 e) \\
\hat x_3 &\leftarrow \hat x_3 + T_s (\beta_3 e)
\end{aligned}
$$

### 5.2 控制律

$$
v = k_p (r - \hat x_1) + k_d (\dot r - \hat x_2)
$$

$$
u = \frac{v - \hat x_3}{b_0}
$$

### 5.3 简化伪代码（便于照搬到 C++/Python/ROS 控制器）

```text
given: Ts, b0, wo, wc
beta1=3*wo; beta2=3*wo*wo; beta3=wo*wo*wo
kp=wc*wc;  kd=2*wc

loop every Ts:
	measure y
	# (optional) update TD -> get r_smooth, rdot

	e = y - x1_hat
	x1_hat += Ts * (x2_hat + beta1*e)
	x2_hat += Ts * (x3_hat + b0*u_prev + beta2*e)
	x3_hat += Ts * (beta3*e)

	v = kp*(r - x1_hat) + kd*(rdot - x2_hat)
	u = (v - x3_hat) / b0
	u = clamp(u, u_min, u_max)
	apply u
	u_prev = u
```

工程建议：

- **加饱和**（`clamp`）几乎必需，尤其是执行器有限幅。
- 若饱和频繁，ESO 会把“饱和造成的跟踪误差”也当成扰动去估计，可能引发不适（见下文常见坑）。
- 数值积分可用更稳定的离散化（Tustin/矩阵指数），但欧拉法在足够高频下通常可用。

---

## 6. 调参指南（最实用部分）

ADRC 的调参可以非常“带宽化”。你主要需要决定：

- $b_0$：输入增益估计
- $\omega_c$：闭环带宽（决定“想要多快”）
- $\omega_o$：观测器带宽（决定“估计多快”）

### 6.1 如何选 $b_0$

粗略原则：$b_0$ 取“输入对加速度/速度变化的影响量级”。

- 如果你能通过实验估计：给一个固定 $u$，观察 $\ddot y$（或 $\dot y$ 的斜率），就能估 $b$。
- 不要取错符号：$b_0$ 的符号必须和实际一致。

偏差影响：

- $b_0$ 偏小：控制会偏“猛”（因为除以小数），更容易饱和/抖动。
- $b_0$ 偏大：控制偏“软”，响应变慢。

### 6.2 先定 $\omega_c$（你希望的响应速度）

粗略经验：

- 想要更快：增大 $\omega_c$（$k_p,k_d$ 变大）
- 但过大会带来：噪声敏感、执行器饱和、结构振动被激发

建议做法：从小到大逐步加，观察超调、震荡、饱和比例。

### 6.3 再定 $\omega_o$（观测器速度）

常见经验比值：

$$
\omega_o \approx (3\sim 10)\,\omega_c
$$

- $\omega_o$ 太小：扰动估计慢，补偿不及时，表现像“普通 PD”。
- $\omega_o$ 太大：对测量噪声极敏感，$\hat x_2,\hat x_3$ 抖动，控制输入抖动。

如果传感器噪声较大（IMU、速度估计抖），宁可把 $\omega_o$ 收敛一些，并用合适滤波/更好状态估计。

---

## 7. ADRC 与 PID 的关系：为什么很多人说它“更鲁棒”

把 LESO 的扰动补偿展开看，它相当于：

- 用观测器“替你做了 D 项”（而且更稳健、可调）
- 用 $\hat f$ 做前馈补偿（PID 里通常没有显式总扰动补偿）

因此在负载突变、摩擦变化、外界推力干扰下，ADRC 往往能表现出更小的稳态误差和更快的恢复。

但要注意：ADRC 并不是“不要模型”，它仍然需要 **$b_0$ 的量级**，并且仍受采样率、噪声、饱和等工程因素制约。

---

## 8. 常见坑与排查

### 8.1 噪声导致控制抖动

症状：$u$ 高频抖动，$\hat x_2,\hat x_3$ 抖。

处理：

- 降低 $\omega_o$（优先）
- 适当降低 $\omega_c$
- 改善测量滤波/传感器融合（例如速度用滤波或观测器）
- 提高采样率

### 8.2 执行器饱和 / 死区 / 摩擦导致“估计错方向”

饱和时真实系统不再满足“输入增益 $b$ 恒定”的近似，ESO 会把误差当扰动估计，可能引发积分式漂移或补偿过度。

处理：

- 降低 $\omega_c$ 或限制 $v$，减少饱和发生
- 做饱和与死区补偿（如果你明确知道执行器特性）
- 在控制律层面引入抗饱和策略（简单起见先减少指令）

### 8.3 $b_0$ 符号错/量级差太大

症状：系统发散或控制方向反了。

处理：

- 先确认 $u$ 增大会让 $y$ 按预期方向加速/变化
- 把 $b_0$ 调到合理量级（可用小输入试验估计）

### 8.4 采样周期太大

ADRC 尤其是 ESO 依赖高频更新。若 $T_s$ 大，观测器离散化误差与延迟会显著影响稳定性。

经验：

- 控制频率越高越好（常见 200 Hz、500 Hz、1 kHz）
- $\omega_o$ 与 $\omega_c$ 不要大到超过离散系统可承受范围

---

## 9. 你可以怎么把它用到机器人里（最小落地建议）

如果你在做底盘速度/姿态控制（比如电机转速、车体角速度），通常建议：

1. 先用传统 PID 把系统跑起来，得到一个“可工作的带宽”和饱和范围
2. 换 ADRC：保持类似闭环速度（$\omega_c$），再逐步增大 $\omega_o$
3. 重点观察：扰动下的恢复时间、饱和占比、噪声抖动

---

## 10. 术语对照（便于查资料）

- ADRC：Active Disturbance Rejection Control
- ESO / LESO：Extended State Observer / Linear ESO
- NLSEF：Nonlinear State Error Feedback（很多实现会用 `fal` 函数）
- TD：Tracking Differentiator
- Total disturbance：总扰动（外扰 + 内扰 + 未建模）
- Bandwidth parameterization：带宽参数化（$\omega_c,\omega_o$）

---

## 11. 下一步（如果你愿意给一点信息，我可以继续把它写成“针对你项目的版本”）

你现在想控制的对象是什么？（选 1~2 个就行）

- 电机转速 / 位置（带编码器）
- 底盘 $v_x, v_y, \omega$（麦轮/全向）
- 云台角度/角速度

以及：采样周期 $T_s$ 大概是多少、控制量 $u$ 的范围是多少。

有了这些，我可以把本页补充成：**针对你的对象写出一套具体参数起点**（$b_0,\omega_c,\omega_o$）和对应的 ROS 控制循环伪代码。